package com.alessandra_alessandro.ketchapp.controllers;

import com.alessandra_alessandro.ketchapp.kafka.KafkaProducer;
import com.alessandra_alessandro.ketchapp.models.dto.PlanBuilderRequestDto;
import com.alessandra_alessandro.ketchapp.models.dto.PlanBuilderResponseDto;
import com.alessandra_alessandro.ketchapp.models.dto.TomatoDto;
import com.alessandra_alessandro.ketchapp.models.entity.TomatoEntity;
import com.alessandra_alessandro.ketchapp.models.entity.UserEntity;
import com.alessandra_alessandro.ketchapp.repositories.TomatoesRepository;
import com.alessandra_alessandro.ketchapp.repositories.UsersRepository;
import com.alessandra_alessandro.ketchapp.utils.EntityMapper;
import com.alessandra_alessandro.ketchapp.utils.GeminiApi;
import com.fasterxml.jackson.core.JsonProcessingException;
import jakarta.servlet.http.HttpServletRequest;
import java.io.IOException;
import java.net.URI;
import java.net.URLEncoder;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.charset.StandardCharsets;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

@Service
public class PlanBuilderControllers {

    private static final Logger log = LoggerFactory.getLogger(
        PlanBuilderControllers.class
    );
    private final TomatoesRepository tomatoesRepository;
    private final UsersRepository usersRepository;
    private final GeminiApi geminiApi;
    private final EntityMapper entityMapper;
    private final KafkaProducer kafkaProducer;

    @Autowired
    public PlanBuilderControllers(
        TomatoesRepository tomatoesRepository,
        UsersRepository usersRepository,
        GeminiApi geminiApi,
        EntityMapper entityMapper,
        KafkaProducer kafkaProducer
    ) {
        this.tomatoesRepository = tomatoesRepository;
        this.usersRepository = usersRepository;
        this.geminiApi = geminiApi;
        this.entityMapper = entityMapper;
        this.kafkaProducer = kafkaProducer;
    }

    /**
     * Creates a new study plan using the provided response DTO.
     * Saves tomato data to the database, sends an email notification to the user,
     * and returns the response generated by the Gemini API.
     *
     * @param dto DTO containing information for plan creation
     * @return ResponseEntity with the generated request DTO or error in case of failure
     * @throws JsonProcessingException
     */
    public ResponseEntity<PlanBuilderRequestDto> createPlanBuilder(
        PlanBuilderResponseDto dto
    ) {
        log.info("Received PlanBuilderResponseDto: {}", dto);
        PlanBuilderRequestDto geminiResponse = geminiApi.ask(dto);
        log.info("Gemini API response: {}", geminiResponse);
        if (geminiResponse == null) {
            log.info("Gemini response is null, returning bad request");
            return ResponseEntity.badRequest().build();
        }

        saveTomatoesFromGeminiResponse(dto, geminiResponse);
        String userEmail = resolveUserEmail(dto.getUserId());
        kafkaProducer.sendToKafka(userEmail, geminiResponse);
        return ResponseEntity.ok(geminiResponse);
    }

    /**
     * Saves the tomato entities extracted from the Gemini API response to the database.
     *
     * @param dto            The DTO containing user information.
     * @param geminiResponse The response DTO from the Gemini API.
     */
    private void saveTomatoesFromGeminiResponse(
        PlanBuilderResponseDto dto,
        PlanBuilderRequestDto geminiResponse
    ) {
        if (geminiResponse.getSubjects() == null) return;
        for (var subject : geminiResponse.getSubjects()) {
            log.info("Processing subject: {}", subject.getName());
            var tomatoes = subject.getTomatoes();
            if (tomatoes == null) continue;
            TomatoEntity prevTomato = null;
            for (PlanBuilderRequestDto.Tomato tomato : tomatoes) {
                log.info("Processing tomato: {}", tomato);
                var tomatoDto = TomatoDto.fromPlanBuilderTomato(
                    tomato,
                    dto.getUserId(),
                    subject.getName(),
                    prevTomato != null ? prevTomato.getId() : null
                );
                TomatoEntity tomatoEntity = entityMapper.tomatoDtoToEntity(
                    tomatoDto
                );
                log.info("Saving TomatoEntity: {}", tomatoEntity);
                TomatoEntity savedTomato = tomatoesRepository.save(
                    tomatoEntity
                );
                if (prevTomato != null) {
                    prevTomato.setNextTomatoId(savedTomato.getId());
                    log.info(
                        "Updating prevTomato with nextTomatoId: {}",
                        savedTomato.getId()
                    );
                    tomatoesRepository.save(prevTomato);
                }
                prevTomato = savedTomato;
            }
        }
    }

    /**
     * Resolves the user's email address from the user UUID.
     */
    private String resolveUserEmail(java.util.UUID userUUID) {
        String userEmail = usersRepository
            .findById(userUUID)
            .map(UserEntity::getEmail)
            .orElse("");
        log.info("User email resolved: {}", userEmail);
        return userEmail;
    }

    /**
     * Sends an email notification to the user with the Gemini API response.
     *
     * @param userEmail      The email address of the user.
     * @param geminiResponse The response DTO from the Gemini API.
     */
    private void sendEmailNotification(
        String userEmail,
        PlanBuilderRequestDto geminiResponse
    ) {
        // Sanitize email: trim whitespace and remove newlines
        String cleanEmail = userEmail == null
            ? ""
            : userEmail.trim().replaceAll("[\r\n]+", "");
        String mailUrl =
            "http://151.61.228.91:8082/api/mail/" +
            URLEncoder.encode(cleanEmail, StandardCharsets.UTF_8);
        log.info(
            "Sending email request to: {} with payload: {}",
            mailUrl,
            geminiResponse.toJson()
        );

        // Retrieve JWT from the current request context
        String jwt = getCurrentJwtToken();
        if (jwt == null || jwt.isEmpty()) {
            log.error(
                "JWT token not found in the current request context. Email will not be sent."
            );
            return;
        }

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(mailUrl))
            .header("Content-Type", "application/json")
            .header("Authorization", "Bearer " + jwt)
            .POST(HttpRequest.BodyPublishers.ofString(geminiResponse.toJson()))
            .build();

        try {
            HttpClient client = HttpClient.newHttpClient();
            log.info("Sending email notification request...");
            HttpResponse<String> response = client.send(
                request,
                HttpResponse.BodyHandlers.ofString()
            );
            log.info(
                "Email notification response status: {}, body: {}",
                response.statusCode(),
                response.body()
            );
            if (response.statusCode() != 200) {
                log.error(
                    "Error sending email notification: {}",
                    response.body()
                );
            } else {
                log.info("Email notification sent successfully.");
            }
        } catch (IOException | InterruptedException e) {
            log.error("Exception sending email notification", e);
        }
    }

    private String getCurrentJwtToken() {
        // Retrieve the JWT from the current HTTP request header
        try {
            ServletRequestAttributes attr =
                (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
            if (attr == null) return null;
            HttpServletRequest request = attr.getRequest();
            String authHeader = request.getHeader("Authorization");
            if (authHeader != null && authHeader.startsWith("Bearer ")) {
                return authHeader.substring(7);
            }
            return null;
        } catch (Exception e) {
            log.error("Could not extract JWT from HTTP request", e);
            return null;
        }
    }
}
