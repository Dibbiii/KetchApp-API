package com.alessandra_alessandro.ketchapp.controllers;

import com.alessandra_alessandro.ketchapp.models.dto.AchievementDto;
import com.alessandra_alessandro.ketchapp.models.dto.PlanBuilderRequestDto;
import com.alessandra_alessandro.ketchapp.models.dto.PlanBuilderResponseDto;
import com.alessandra_alessandro.ketchapp.utils.GeminiApi;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Autowired;

import com.alessandra_alessandro.ketchapp.models.entity.TomatoEntity;
import com.alessandra_alessandro.ketchapp.models.entity.UserEntity;
import com.alessandra_alessandro.ketchapp.repositories.TomatoesRepository;
import com.alessandra_alessandro.ketchapp.repositories.UsersRepository;

import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.sql.Timestamp;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.io.IOException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Service
public class PlanBuilderControllers {
    private static final Logger log = LoggerFactory.getLogger(PlanBuilderControllers.class);
    private final TomatoesRepository tomatoesRepository;
    private final UsersRepository usersRepository;
    private final GeminiApi geminiApi;

    @Autowired
    public PlanBuilderControllers(TomatoesRepository tomatoesRepository, UsersRepository usersRepository, GeminiApi geminiApi) {
        this.tomatoesRepository = tomatoesRepository;
        this.usersRepository = usersRepository;
        this.geminiApi = geminiApi;
    }

    /**
     * Creates a new study plan using the provided response DTO.
     * Saves tomato data to the database, sends an email notification to the user,
     * and returns the response generated by the Gemini API.
     *
     * @param dto DTO containing information for plan creation
     * @return ResponseEntity with the generated request DTO or error in case of failure
     */
    public ResponseEntity<PlanBuilderRequestDto> createPlanBuilder(PlanBuilderResponseDto dto) {
        log.debug("Received PlanBuilderResponseDto: {}", dto);
        PlanBuilderRequestDto geminiResponse = (PlanBuilderRequestDto) geminiApi.ask(dto);
        log.debug("Gemini API response: {}", geminiResponse);
        if (geminiResponse == null) {
            log.debug("Gemini response is null, returning bad request");
            return ResponseEntity.badRequest().build();
        }

        saveTomatoesFromGeminiResponse(dto, geminiResponse);
        String userEmail = resolveUserEmail(dto.getUserUUID());
        sendEmailNotification(userEmail, geminiResponse);
        return ResponseEntity.ok(geminiResponse);
    }

    /**
     * Saves the tomato entities extracted from the Gemini API response to the database.
     *
     * @param dto            The DTO containing user information.
     * @param geminiResponse The response DTO from the Gemini API.
     */
    private void saveTomatoesFromGeminiResponse(PlanBuilderResponseDto dto, PlanBuilderRequestDto geminiResponse) {
        if (geminiResponse.getSubjects() == null) return;
        for (var subject : geminiResponse.getSubjects()) {
            log.debug("Processing subject: {}", subject.getName());
            var tomatoes = subject.getTomatoes();
            if (tomatoes == null) continue;
            TomatoEntity prevTomato = null;
            for (PlanBuilderRequestDto.Tomato tomato : tomatoes) {
                log.debug("Processing tomato: {}", tomato);
                TomatoEntity tomatoEntity = createTomatoEntity(dto, tomato, subject.getName(), prevTomato);
                log.debug("Saving TomatoEntity: {}", tomatoEntity);
                TomatoEntity savedTomato = tomatoesRepository.save(tomatoEntity);
                if (prevTomato != null) {
                    prevTomato.setNextTomatoId(savedTomato.getId());
                    log.debug("Updating prevTomato with nextTomatoId: {}", savedTomato.getId());
                    tomatoesRepository.save(prevTomato);
                }
                prevTomato = savedTomato;
            }
        }
    }

    /**
     * Creates a TomatoEntity from the provided data.
     */
    private TomatoEntity createTomatoEntity(PlanBuilderResponseDto dto, PlanBuilderRequestDto.Tomato tomato, String subjectName, TomatoEntity prevTomato) {
        return new TomatoEntity(
                dto.getUserUUID(),
                parseIsoToTimestamp(tomato.getStart_at()),
                parseIsoToTimestamp(tomato.getEnd_at()),
                parseIsoToTimestamp(tomato.getPause_end_at()),
                prevTomato != null ? prevTomato.getId() : null,
                subjectName
        );
    }

    /**
     * Resolves the user's email address from the user UUID.
     */
    private String resolveUserEmail(java.util.UUID userUUID) {
        String userEmail = usersRepository.findById(userUUID)
                .map(UserEntity::getEmail)
                .orElse("");
        log.debug("User email resolved: {}", userEmail);
        return userEmail;
    }

    /**
     * Sends an email notification to the user with the Gemini API response.
     *
     * @param userEmail      The email address of the user.
     * @param geminiResponse The response DTO from the Gemini API.
     */
    private void sendEmailNotification(String userEmail, PlanBuilderRequestDto geminiResponse) {
        String mailUrl = "http://151.61.228.91:8082/api/mail/" + URLEncoder.encode(userEmail, StandardCharsets.UTF_8);
        log.debug("Sending email request to: {} with payload: {}", mailUrl, geminiResponse.toJson());
        HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create(mailUrl))
                .header("Content-Type", "application/json")
                .POST(HttpRequest.BodyPublishers.ofString(geminiResponse.toJson()))
                .build();

        try {
            HttpClient client = HttpClient.newHttpClient();
            log.debug("Sending email notification request...");
            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
            log.debug("Email notification response status: {}, body: {}", response.statusCode(), response.body());
            if (response.statusCode() != 200) {
                log.error("Error sending email notification: {}", response.body());
            } else {
                log.info("Email notification sent successfully.");
            }
        } catch (IOException | InterruptedException e) {
            log.error("Exception sending email notification", e);
        }
    }

    /**
     * Converts an ISO 8601 formatted string to a Timestamp object.
     * Supports strings with 'Z' (UTC), with 'T' (LocalDateTime), or plain timestamp strings.
     *
     * @param isoString the ISO 8601 formatted string to convert
     * @return the corresponding Timestamp, or null if the string is empty or null
     * @throws IllegalArgumentException if the string is not in a valid format
     */
    private Timestamp parseIsoToTimestamp(String isoString) {
        if (isoString == null || isoString.isEmpty()) return null;
        try {
            if (isoString.endsWith("Z")) {
                return Timestamp.from(Instant.parse(isoString));
            } else if (isoString.contains("T")) {
                LocalDateTime ldt = LocalDateTime.parse(isoString, DateTimeFormatter.ISO_LOCAL_DATE_TIME);
                return Timestamp.valueOf(ldt);
            } else {
                return Timestamp.valueOf(isoString);
            }
        } catch (Exception e) {
            throw new IllegalArgumentException("Invalid timestamp string: " + isoString, e);
        }
    }
}